package agf.ui.ctrl{	import flash.events.Event;	import flash.events.FocusEvent;	import flash.text.TextField;	import flash.text.TextFieldType;	//import t3cm.ftm.BaseNode;	import flash.display.Sprite;	import agf.html.CssUtils;
		dynamic public class WEColorInput extends UiCtrl 	{		public function WEColorInput (w:int=120) {						var h:Number = UiCtrl.defaultInputTextFmt.size+4;						tf = createTextField();			tf.defaultTextFormat = UiCtrl.defaultInputTextFmt;			tf.type = TextFieldType.INPUT;			tf.selectable = true;			tf.width = w;			tf.height = h;			//tf.background = true;			//tf.backgroundColor = UiCtrl.INPUT_BACKGROUND_COLOR;			//tf.border = true;			//tf.borderColor = UiCtrl.INPUT_BORDER_COLOR;			tf.addEventListener(FocusEvent.FOCUS_IN, activateHandler);			tf.addEventListener(FocusEvent.FOCUS_OUT, deactivateHandler);						bg = new Sprite();			drawInputBg(bg, w,h, roundLeft, roundRight );						color = 0;						addChild(bg);			addChild(tf);		}				protected var _textAlign:String="left";		public static var displayMode:String="rgb"; // rgb or hex				private var activateValue:int=0;				private function activateHandler (e:Event) :void {			activateValue = color;			focusIn();		}				private function deactivateHandler (e:Event) :void {			processEnter()			focusOut();		}				public function set textAlign (v:String) :void {			if(v == _textAlign) return;						_textAlign = v;			if(_textAlign == "left") {				tf.defaultTextFormat = _enabled ? UiCtrl.defaultInputTextFmtLeft : UiCtrl.disabledInputTextFmtLeft;			}else{				// right				tf.defaultTextFormat = _enabled ? UiCtrl.defaultInputTextFmt : UiCtrl.disabledInputTextFmt;			}		}				public function get textAlign () :String {			return _textAlign;		}				private var _color:uint=0;				public function processEnter () :void {			color = tf.text;			dispatchEvent( new Event(Event.CHANGE) );		}				public function processEsc () :void {			color = activateValue;		}				public override function set enabled (v:Boolean) :void {			//if(_enabled==v) return;		//	trace("Set Color Enabled: " + v);			_enabled = v;						if(_enabled) {								if(_textAlign=="left")					tf.defaultTextFormat = UiCtrl.defaultInputTextFmtLeft;				else					tf.defaultTextFormat = UiCtrl.defaultInputTextFmt;			}else{								if(_textAlign=="left")					tf.defaultTextFormat = UiCtrl.disabledInputTextFmtLeft;				else					tf.defaultTextFormat = UiCtrl.disabledInputTextFmt;			}						tf.textColor = _enabled ? UiCtrl.INPUT_COLOR : UiCtrl.INPUT_DISABLED;		}				public function set color (t:*) :void {						if( t is String ) {				if( String(t).charAt(1) == "x" || String(t).charAt(0) == "#" ) {					displayMode = "hex";				}else if( isNaN(Number(t) ) ) {					displayMode = "rgb";				}				_color = CssUtils.stringToColor(t);			}else{				_color = uint(t);			}						var r:int = _color >> 16 & 255;			var g:int = _color >> 8 & 255;			var b:int = _color & 255;						if(displayMode == "hex") {				var r16:String = r.toString(16);				var g16:String = g.toString(16);				var b16:String = b.toString(16);								if(r16.length == 1) r16 = "0" + r16;				if(g16.length == 1) g16 = "0" + g16;				if(b16.length == 1) b16 = "0" + b16;								tf.text = "#" + r16.toUpperCase() + g16.toUpperCase() + b16.toUpperCase();			}else{				tf.text = "rgb ( " + r+ ", " + g + ", " + b + " )";			}		}				public function get color () :int {			return _color;		}				public override function getWidth():int {			return tf.width;		}		public override function setWidth( w:int):void {			tf.width = w;			drawInputBg( bg, tf.width, tf.height, roundLeft, roundRight  );		}				public override function getHeight():int {			return tf.height-2;		}		public override function setHeight( h:int):void {			tf.height = h;			drawInputBg( bg, tf.width, tf.height, roundLeft, roundRight  );		}				public var tf:TextField;		public var bg:Sprite;	}	}